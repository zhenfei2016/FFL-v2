/*
 *  This file is part of FFL project.
 *
 *  The MIT License (MIT)
 *  Copyright (C) 2017-2018 zhufeifei All rights reserved.
 *
 *  FFL_Clock.cpp 
 *  Created by zhufeifei(34008081@qq.com) on 五月 2018. 
 *  
 *  时钟类，可以获取当前时间，改变时钟速度，修改时钟原点偏移
 *  y=ax +b 
*/

#include <utils/FFL_Clock.hpp>
namespace FFL {
	//
	//   y=(a/KA_RATIO) x +b
	//  当前设置的a参数的放大倍数，实际的值= a/KA_RATIO
	//
	//
	static const int64_t KA_RATIO = 100;

//	Clock::Clock() {
//		reset();
//	}
//	Clock::~Clock() {
//
//	}
//	void Clock::reset() {
//		mOffset = 0;
//		mSpeedPercent = 100;
//		mSpeed = 1.0f;
//		mSystemStartTimeUs = mClockStartTimeUs = 0;
//	}
//	//
//	//  当前时间
//	//
//	int64_t Clock::nowUs() {
//		return nowUs(0);
//	}
//	//
//	//  这个时钟的当前时间  systemUs：返回系统时钟的时间
//	//
//	int64_t Clock::nowUs(int64_t* systemUs) {
//		int64_t now = FFL_getNowUs();
//		//now +=mOffset;
//		if (systemUs) {
//			*systemUs = now;
//		}
//        if (isSystemClock()) {
//            return now;
//        }
//        
//        //
//        //  转化到当前时钟的时间值
//        //
//        int64_t clockNow = 0;			
//        clockNow = mClockStartTimeUs + (int64_t)(mSpeed * (now - mSystemStartTimeUs));
//        FFL_WARNING("Clock sys:%" lld64 " clock:%" lld64, now, clockNow);
//        mClockStartTimeUs = clockNow;
//        mSystemStartTimeUs = now;
//        return clockNow;
//	
//	}
//	//
//	//  转换当前时钟的一个时间段转成系统时钟时间段
//	//  例如可以把当前时钟5分钟转成系统时钟8分钟
//	//
//	int64_t Clock::clockToSystemRelativeUs(int64_t clockUs) {
//        if(isSystemClock()){
//            return clockUs;
//        }
//        
//        return (int64_t)((double)clockUs/mSpeed);
//        
//		
//	}
//	int64_t Clock::SystemToClockRelativeUs(int64_t systemUs) {
//		if (mSpeedPercent % 100 == 0) {
//			return (mSpeedPercent / 100) * systemUs;
//		}
//
//		return (int64_t)(mSpeed * (systemUs));
//	}
//	//
//	//  时钟速度，默认1.0时正常时钟值
//	//
//	uint32_t Clock::speed() {
//		return mSpeedPercent;
//	}
//	void Clock::setSpeed(uint32_t percent) {
//		if (percent != mSpeedPercent) {			
//			update();
//			mSpeedPercent = percent;
//			mSpeed=(double) mSpeedPercent/100;
//		}
//	}
//	//
//	//  偏移
//	//
//	int64_t Clock::offset() {
//		return mOffset;
//	}
//	void Clock::setOffset(int64_t offset) {
//		mOffset = offset;
//	}
//	void Clock::update(){		
//		mClockStartTimeUs = nowUs(&mSystemStartTimeUs);
//		
////		if (mSpeedPercent!=100 && abs(mSystemTimeUs - mClockTimeUs) < 10) {
////			//
////			//  差值时间值<10 us则表示2个时间轴一样的
////			//
////			mSystemTimeUs = 0;
////			mClockTimeUs = 0;
////		}
//	}
//    //
//    //  是否系统时钟一致的
//    //
//    bool Clock::isSystemClock(){
//        return  mSpeedPercent==100;
//    }

	static int64_t getY(int64_t x,int64_t a) {
		return (int64_t)((double)(x * a) / KA_RATIO);
	}

Clock::Clock() {
	reset();
}
Clock::~Clock() {

}
void Clock::reset() {
	mB = 0;
	mA = KA_RATIO;
}

//
//  当前时间
//
int64_t Clock::nowUs() {
	return nowUs(0);
}
//
//  这个时钟的当前时间  systemUs：返回系统时钟的时间
//
int64_t Clock::nowUs(int64_t* systemUs) {
	int64_t now = FFL_getNowUs();	
	if (systemUs) {
		*systemUs = now;
	}
	if (equalSystemClock()) {
		return now;
	}

	//
	//  转化到当前时钟的时间值
	//  y=ax +b
	//	
	int64_t clockNow=getY(now,mA) + mB;
	FFL_WARNING("Clock x:%" lld64 " y:%" lld64 "a=%" lld64 " b=%" lld64, now, clockNow, mA,mB);
	return clockNow;

}
//
//  转换当前时钟的一个时间段转成系统时钟时间段
//  例如可以把当前时钟5分钟转成系统时钟8分钟
//
int64_t Clock::clockToSystemRelativeUs(int64_t dy) {
	//
	// y=ax+b
	// 计算dx
	//
	return (int64_t)(double)(dy * 100) / mA;
}
int64_t Clock::SystemToClockRelativeUs(int64_t dx) {
	//
	// y=ax+b
	// 计算dy
	//
	return (int64_t)((double)(dx *  mA)/100);
}
//
//  时钟速度，默认1.0时正常时钟值
//
uint32_t Clock::speed() {
	return mA;
}
void Clock::setSpeed(uint32_t percent) {
	if (percent != mA) {
		int64_t x;
		int64_t y = nowUs(&x);

		//
		//  计算新的a,b参数
		//  b=y-ax
		//
		mB = y -(int64_t)( (double)(mA* x) / KA_RATIO);
		mA = percent;
	}

	//if (percent != mSpeedPercent) {
	//	update();
	//	mSpeedPercent = percent;
	//	mSpeed = (double)mSpeedPercent / 100;
	//}
}
//
//  偏移
//
int64_t Clock::offset() {
	return mB;
}
void Clock::setOffset(int64_t offset) {
	//mB = offset;
}
void Clock::update() {
	//mB = mSystemStartTimeUs * mA;

	//mClockStartTimeUs = nowUs(&mSystemStartTimeUs);

	
	//		if (mSpeedPercent!=100 && abs(mSystemTimeUs - mClockTimeUs) < 10) {
	//			//
	//			//  差值时间值<10 us则表示2个时间轴一样的
	//			//
	//			mSystemTimeUs = 0;
	//			mClockTimeUs = 0;
	//		}
}
//
//  是否系统时钟一致的
//
bool Clock::equalSystemClock() {	
	return mA == KA_RATIO;
}

}
